% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recommendDTR.cont.multi.R
\name{recommendDTR.cont.multi}
\alias{recommendDTR.cont.multi}
\title{Recommend the optimal treatment at each stage (Continuous Treatment and Multiple Outcomes)}
\usage{
recommendDTR.cont.multi(
  DTRs,
  currentDTRs = NULL,
  X.new,
  A.new = NULL,
  Y.new = NULL,
  A.cnstr.func = NULL,
  n.grid = 100,
  parallel = FALSE,
  parallel.package = NULL,
  verbose = NULL
)
}
\arguments{
\item{DTRs}{Output from \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}} that belong to class \code{metaDTR}.}

\item{currentDTRs}{Object from \code{\link[=recommendDTR.cont.multi]{recommendDTR.cont.multi()}}. Records the results from previous stages so that users can
flexibly make predictions stage by stage. See details and example.}

\item{X.new}{A list of covariates at each stage. In practice, since recommendations are made
stage by stage, here one stage of \code{X.new} will provide one stage's recommendation of action.}

\item{A.new}{A list of observed or predicted actions (from the algorithm). Users can provide real actions observed
rather than algorithm recommended to make this function more flexible.
It allows to handle cases that the realized action/observation may not be consistent
with algorithm results. Only needed when \code{all.inclusive = TRUE}.
Default is \code{NULL}.}

\item{Y.new}{A list. Required if \code{include.Y > 0} in \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}}. Default is \code{NULL}}

\item{A.cnstr.func}{Same as in \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}}. Provide a chance for it to be override, not very common though.
If not specified, it will be inherited directly from the returns of \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}}.}

\item{n.grid}{Same as in \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}}. If not specified, it will be inherited from \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}}.}

\item{parallel}{A boolean, for whether parallel computing is adopted. Also, if a numeric value, it implies the
number of cores to use. Otherwise, directly use the number from \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}}}

\item{parallel.package}{One of c("doMC", "snow", "doParallel"), the parallel package to use.}

\item{verbose}{Console output allowed? Default is \code{NULL}, which will inherit the argument input of}
}
\value{
It returns the optimal action/treatment recommendations at each stage and results are stored in a list for
each meta-learner method.
}
\description{
This function make recommendations of optimal treatment for a given subject at given stage
}
\details{
This function make recommendations based on the trained learners from \code{\link[=learnDTR.cont.multi]{learnDTR.cont.multi()}} for new dataset.
Since in real application, later stage covariates/outcomes are unobservable until treatments are
assigned. So in most cases, \code{\link[=recommendDTR.cont.multi]{recommendDTR.cont.multi()}} needs to be applied stage by stage, which is allowed in
this package. User can provide available information stage by stage, and obtain the optimal recommendations
at each stage, iteratively.
}
\examples{
## Similar example as recommendDTR()
## First: Modify dataset to 2 actions and 2 outcomes:
tmp = ThreeStg_Dat
tmp$X = lapply(tmp$X, function(x) as.data.frame(apply(x, 2, scale)))
tmp$X.test = lapply(tmp$X.test, function(x) as.data.frame(apply(x, 2, scale)))
tmp$A = lapply(tmp$A, function(x) cbind(rnorm(400,0,1), rnorm(400,0,2)))
tmp$Y = lapply(tmp$Y, function(x) cbind(x, rnorm(400,0,0.2)+x*runif(400,0,1)))

## Apply the main function to learn the DTRs
DTRs = learnDTR.cont.multi(X = tmp$X,
                          A = tmp$A,
                          Y = tmp$Y,
                          weights = rep(1, 3),
                          weights.Y = c(0.3,0.7),
                          baseLearner  = c("XGBoost"),
                          metaLearners = c("S"),
                          include.X = 1,
                          include.A = 2,
                          include.Y = 0,
                          A.box.cnstr = cbind(c(-2,2), c(-2,2)),
                          A.cnstr.func = function(a, x) {
                            abs(a[,1]+x[1]) + abs(a[,2]+x[2]) <= 3
                          },
                          x.select = c("V1", "V2"),
                          n.grid = 50,
                          parallel = FALSE)
## Second: Find DTR on test set
optDTR <- recommendDTR.cont.multi(DTRs, currentDTRs = NULL, n.grid = 50,
                        X.new = tmp$X.test, parallel = FALSE, verbose = TRUE)
}
\seealso{
\code{\link{learnDTR.cont.multi}}
}
\author{
Junyi Zhou \email{junyzhou@iu.edu}
}
